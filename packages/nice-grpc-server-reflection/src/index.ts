import {ServiceImplementation, Status} from 'nice-grpc';
import {
  DescriptorProto,
  EnumDescriptorProto,
  FileDescriptorProto,
  FileDescriptorSet,
  MethodDescriptorProto,
  ServiceDescriptorProto,
} from 'google-protobuf/google/protobuf/descriptor_pb';
import {IServerReflectionService} from './proto/grpc/reflection/v1/reflection_grpc_pb';
import {
  ErrorResponse,
  ExtensionNumberResponse,
  FileDescriptorResponse,
  ListServiceResponse,
  ServerReflectionRequest,
  ServerReflectionResponse,
  ServiceResponse,
} from './proto/grpc/reflection/v1/reflection_pb';
import {BinaryReader} from 'google-protobuf';

export {ServerReflectionService} from './proto/grpc/reflection/v1/reflection_grpc_pb';

/**
 * Deserialization implementation of `google.protobuf.FileDescriptorSet` able
 * to track the source slice for each file.
 *
 * The deserialization logic is based on the protobuf definitions and the code
 * generated in the `google-protobuf` package.
 *
 * For each deserialized file descriptor, the source slice is attached to it
 * in the `fileSource` weakmap.
 */
function deserializeFileDescriptorSetWithFileSource(
  bytes: Uint8Array,
  fileSource: WeakMap<FileDescriptorProto, Uint8Array>,
): FileDescriptorSet {
  const reader = new BinaryReader(bytes);
  const msg = new FileDescriptorSet();
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    const field: number = reader.getFieldNumber();
    switch (field) {
      case 1: {
        const value = new FileDescriptorProto();
        // offset of the message start, null if the reader is never called
        let start: null | number = null;
        reader.readMessage(value, (msg: any, binaryReader: BinaryReader) => {
          if (start === null) {
            start = binaryReader.getCursor();
          }
          return FileDescriptorProto.deserializeBinaryFromReader(
            msg,
            binaryReader,
          );
        });
        const end = reader.getCursor();
        msg.addFile(value);
        if (start !== null && start <= end) {
          fileSource.set(value, bytes.slice(start, end));
        } else {
          throw new Error(
            'Failed to retrieve file descriptor source slice: reader callback not called',
          );
        }
        break;
      }
      default: {
        reader.skipField();
        break;
      }
    }
  }
  return msg;
}

/**
 * Implement the [`grpc.reflection.v1.ServerReflection`](https://github.com/grpc/grpc-proto/blob/master/grpc/reflection/v1/reflection.proto)
 * service for the provided file descriptor set.
 *
 * @param protoset Protobuf-encoded file descriptor set. This is a
 *   protobuf-encoded [google.protobuf.FileDescriptorSet](https://github.com/protocolbuffers/protobuf/blob/89c585602af7d28646ce92cd3abba07cfdad7fa6/src/google/protobuf/descriptor.proto#L56)
 *   value. It is usually generated by the protobuf compiler using the
 *   flag `--descriptor_set_out`. If using the option `fdProtoMode: "slice"`
 *   (default), this value is assumed to be an immutable `Uint8Array` value.
 *   If you can't guarantee immutability, clone the `protoset` value before
 *   passing it to this function (for example, using
 *   `Uint8Array.from(protoset)`).
 * @param serviceNames Allowlist specifying the full name of services to expose.
 *   An empty list means that no service will be exposed.
 */
export function ServerReflection(
  protoset: Uint8Array,
  serviceNames: readonly string[],
): ServiceImplementation<IServerReflectionService> {
  // Map from file descriptor values to their protobuf-encoded representation
  const fdBytes: WeakMap<FileDescriptorProto, Uint8Array> = new WeakMap();
  const fileDescriptorSet = deserializeFileDescriptorSetWithFileSource(
    protoset,
    fdBytes,
  );

  function findSymbol(
    symbol: string,
    descriptor:
      | FileDescriptorProto
      | DescriptorProto
      | EnumDescriptorProto
      | ServiceDescriptorProto
      | MethodDescriptorProto,
    prefix: string = '',
  ):
    | DescriptorProto
    | EnumDescriptorProto
    | ServiceDescriptorProto
    | MethodDescriptorProto
    | undefined {
    if (descriptor instanceof FileDescriptorProto) {
      const packageName = descriptor.getPackage();

      const packagePrefix = packageName == null ? '' : `${packageName}.`;

      return (
        descriptor
          .getMessageTypeList()
          .find(type => findSymbol(symbol, type, packagePrefix)) ||
        descriptor
          .getEnumTypeList()
          .find(type => findSymbol(symbol, type, packagePrefix)) ||
        descriptor
          .getServiceList()
          .find(type => findSymbol(symbol, type, packagePrefix))
      );
    }

    const fullName = prefix + descriptor.getName();

    if (symbol === fullName) {
      return descriptor;
    }

    if (descriptor instanceof DescriptorProto) {
      const messagePrefix = `${fullName}.`;

      return (
        descriptor
          .getNestedTypeList()
          .find(type => findSymbol(symbol, type, messagePrefix)) ||
        descriptor
          .getEnumTypeList()
          .find(type => findSymbol(symbol, type, messagePrefix))
      );
    }

    if (descriptor instanceof ServiceDescriptorProto) {
      const servicePrefix = `${fullName}.`;

      return descriptor
        .getMethodList()
        .find(method => findSymbol(symbol, method, servicePrefix));
    }

    return undefined;
  }

  function handleRequest(
    request: ServerReflectionRequest,
  ): ServerReflectionResponse {
    switch (request.getMessageRequestCase()) {
      case ServerReflectionRequest.MessageRequestCase.FILE_BY_FILENAME: {
        const filename = request.getFileByFilename();

        const fileDescriptorProto: FileDescriptorProto | undefined =
          fileDescriptorSet
            .getFileList()
            .find(file => file.getName() === filename);

        const fileDescriptorBytes: Uint8Array | undefined =
          fileDescriptorProto !== undefined
            ? fdBytes.get(fileDescriptorProto)
            : undefined;

        if (fileDescriptorBytes == null) {
          return new ServerReflectionResponse().setErrorResponse(
            new ErrorResponse()
              .setErrorCode(Status.NOT_FOUND)
              .setErrorMessage(`File not found: ${filename}`),
          );
        }

        return new ServerReflectionResponse()
          .setOriginalRequest(request)
          .setFileDescriptorResponse(
            new FileDescriptorResponse().setFileDescriptorProtoList([
              fileDescriptorBytes,
            ]),
          );
      }

      case ServerReflectionRequest.MessageRequestCase.FILE_CONTAINING_SYMBOL: {
        const symbol = request.getFileContainingSymbol();

        const fileDescriptorProto = fileDescriptorSet
          .getFileList()
          .find(file => findSymbol(symbol, file) != null);

        const fileDescriptorBytes: Uint8Array | undefined =
          fileDescriptorProto !== undefined
            ? fdBytes.get(fileDescriptorProto)
            : undefined;

        if (fileDescriptorBytes == null) {
          return new ServerReflectionResponse().setErrorResponse(
            new ErrorResponse()
              .setErrorCode(Status.NOT_FOUND)
              .setErrorMessage(`Symbol not found: ${symbol}`),
          );
        }

        return new ServerReflectionResponse()
          .setOriginalRequest(request)
          .setFileDescriptorResponse(
            new FileDescriptorResponse().setFileDescriptorProtoList([
              fileDescriptorBytes,
            ]),
          );
      }

      case ServerReflectionRequest.MessageRequestCase
        .FILE_CONTAINING_EXTENSION: {
        const extensionRequest = request.getFileContainingExtension()!;
        const containingType = extensionRequest.getContainingType();
        const extensionNumber = extensionRequest.getExtensionNumber();

        const fileDescriptorProto = fileDescriptorSet
          .getFileList()
          .find(file => {
            const descriptor = findSymbol(containingType, file);

            return (
              descriptor instanceof DescriptorProto &&
              descriptor
                .getExtensionList()
                .some(extension => extensionNumber === extension.getNumber())
            );
          });

        const fileDescriptorBytes: Uint8Array | undefined =
          fileDescriptorProto !== undefined
            ? fdBytes.get(fileDescriptorProto)
            : undefined;

        if (fileDescriptorBytes == null) {
          return new ServerReflectionResponse().setErrorResponse(
            new ErrorResponse()
              .setErrorCode(Status.NOT_FOUND)
              .setErrorMessage(
                `Extension not found: ${containingType}(${extensionNumber})`,
              ),
          );
        }

        return new ServerReflectionResponse()
          .setOriginalRequest(request)
          .setFileDescriptorResponse(
            new FileDescriptorResponse().setFileDescriptorProtoList([
              fileDescriptorBytes,
            ]),
          );
      }

      case ServerReflectionRequest.MessageRequestCase.LIST_SERVICES: {
        return new ServerReflectionResponse()
          .setOriginalRequest(request)
          .setListServicesResponse(
            new ListServiceResponse().setServiceList(
              serviceNames.map(serviceName =>
                new ServiceResponse().setName(serviceName),
              ),
            ),
          );
      }

      case ServerReflectionRequest.MessageRequestCase
        .ALL_EXTENSION_NUMBERS_OF_TYPE: {
        const type = request.getAllExtensionNumbersOfType();

        return new ServerReflectionResponse().setAllExtensionNumbersResponse(
          new ExtensionNumberResponse().setBaseTypeName(type),
        );
      }
    }

    return new ServerReflectionResponse().setErrorResponse(
      new ErrorResponse()
        .setErrorCode(Status.UNIMPLEMENTED)
        .setErrorMessage('Not implemented'),
    );
  }

  return {
    async *serverReflectionInfo(
      requests: AsyncIterable<ServerReflectionRequest>,
    ): AsyncIterable<ServerReflectionResponse> {
      for await (const request of requests) {
        yield handleRequest(request);
      }
    },
  };
}
